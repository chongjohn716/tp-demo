(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.JTopo = factory());
}(this, (function () { 'use strict';

function extendNative (global = window) {
  /**
   * CanvasRenderingContext2D 扩展
   *
   */
  const CanvasRenderingContext2D = global.CanvasRenderingContext2D;

  const ev = 5;

  /**
   *
   * @param {*} a
   * @param {*} b
   * @param {*} c
   * @param {*} d
   * @param {*} e
   */
  CanvasRenderingContext2D.prototype.JTopoRoundRect = function (a, b, c, d, e = ev) {
    this.beginPath();
    this.moveTo(a + e, b);
    this.lineTo(a + c - e, b);
    this.quadraticCurveTo(a + c, b, a + c, b + e);
    this.lineTo(a + c, b + d - e);
    this.quadraticCurveTo(a + c, b + d, a + c - e, b + d);
    this.lineTo(a + e, b + d);
    this.quadraticCurveTo(a, b + d, a, b + d - e);
    this.lineTo(a, b + e);
    this.quadraticCurveTo(a, b, a + e, b);
    this.closePath();
  };

  /**
   *
   * @param {*} a
   * @param {*} b
   * @param {*} c
   * @param {*} d
   * @param {*} e
   */
  CanvasRenderingContext2D.prototype.JTopoDashedLineTo = function (a, b, c, d, e = ev) {
    const f = c - a;
    const g = d - b;
    const h = Math.floor(Math.sqrt(f * f + g * g));
    const i = e <= 0 ? h : h / e;
    const j = g / h * e;
    const k = f / h * e;
    this.beginPath();
    for (let l = 0; i > l; l++) {
      l % 2 ? this.lineTo(a + l * k, b + l * j) : this.moveTo(a + l * k, b + l * j);
    }
    this.stroke();
  };

  // 兼容处理和扩展方法
  window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (a) {
    setTimeout(a, 1e3 / 24);
  };

  window.console || (window.console = {
    log: function () { },
    info: function () { },
    debug: function () { },
    warn: function () { },
    error: function () { }
  });
}

const SceneMode = {
  normal: 'normal',
  drag: 'drag',
  edit: 'edit',
  select: 'select'
};

const MouseCursor = {
  normal: 'default',
  pointer: 'pointer',
  top_left: 'nw-resize',
  top_center: 'n-resize',
  top_right: 'ne-resize',
  middle_left: 'e-resize',
  middle_right: 'e-resize',
  bottom_left: 'ne-resize',
  bottom_center: 'n-resize',
  bottom_right: 'nw-resize',
  move: 'move',
  open_hand: 'url(./img/cur/openhand.cur) 8 8, default',
  closed_hand: 'url(./img/cur/closedhand.cur) 8 8, default'
};

const version = '0.0.1';

const defaultZIndex = {
  container: 1,
  link: 2,
  node: 3
};

const minus270 = -(Math.PI / 2 + Math.PI / 4);

var aa = {
  aa: 1,
  bb: 2
}

function EditableElement() {
  console.log(aa);
}

util.extend(EditableElement, InteractiveElement);

EditableElement.prototype.initialize = function () {
  EditableElement.super.initialize.apply(this, arguments);
  // EditableElement.prototype.initialize.apply(this, arguments),
  this.editAble = false;
  this.selectedPoint = null;
};
EditableElement.prototype.getCtrlPosition = function (a) {
  const b = 5;
  const c = 5;
  const d = this.getPosition(a);
  return {
    left: d.x - b,
    top: d.y - c,
    right: d.x + b,
    bottom: d.y + c
  }
};
EditableElement.prototype.selectedHandler = function (b) {
  EditableElement.super.selectedHandler.apply(this, arguments);
  this.selectedSize = {
    width: this.width,
    height: this.height
  };
  b.scene.mode === SceneMode.edit && (this.editAble = true);
};
EditableElement.prototype.unselectedHandler = function () {
  EditableElement.super.unselectedHandler.apply(this, arguments);
  this.selectedSize = null;
  this.editAble = false;
};

const CTRL_POSTIONS = ['Top_Left', 'Top_Center', 'Top_Right', 'Middle_Left', 'Middle_Right', 'Bottom_Left', 'Bottom_Center', 'Bottom_Right'];

EditableElement.prototype.paintCtrl = function (a) {
  if (this.editAble) {
    a.save();
    for (let c = 0; c < CTRL_POSTIONS.length; c++) {
      const d = this.getCtrlPosition(CTRL_POSTIONS[c]);
      d.left -= this.cx;
      d.right -= this.cx;
      d.top -= this.cy;
      d.bottom -= this.cy;
      const e = d.right - d.left;
      const f = d.bottom - d.top;
      a.beginPath();
      a.strokeStyle = 'rgba(0,0,0,0.8)';
      a.rect(d.left, d.top, e, f);
      a.stroke();
      a.closePath();
      a.beginPath();
      a.strokeStyle = 'rgba(255,255,255,0.3)';
      a.rect(d.left + 1, d.top + 1, e - 2, f - 2);
      a.stroke();
      a.closePath();
    }
    a.restore();
  }
};

EditableElement.prototype.isInBound = function (a, c) {
  this.selectedPoint = null;
  if (this.editAble) {
    for (let e = 0; e < CTRL_POSTIONS.length; e++) {
      const f = this.getCtrlPosition(CTRL_POSTIONS[e]);
      if (a > f.left && a < f.right && c > f.top && c < f.bottom) {
        this.selectedPoint = CTRL_POSTIONS[e];
        return true
      }
    }
  }
  return EditableElement.super.isInBound.apply(this, arguments)
};

EditableElement.prototype.mousedragHandler = function (a) {
  let b, c, d, e;
  if (this.selectedPoint == null) {
    b = this.selectedLocation.x + a.dx;
    c = this.selectedLocation.y + a.dy;
    this.setLocation(b, c);
    this.dispatchEvent('mousedrag', a);
  } else {
    if (this.selectedPoint === 'Top_Left') {
      d = this.selectedSize.width - a.dx;
      e = this.selectedSize.height - a.dy;
      b = this.selectedLocation.x + a.dx;
      c = this.selectedLocation.y + a.dy;
      b < this.x + this.width && (this.x = b, this.width = d);
      c < this.y + this.height && (this.y = c, this.height = e);
    } else if (this.selectedPoint === 'Top_Center') {
      e = this.selectedSize.height - a.dy;
      c = this.selectedLocation.y + a.dy;
      c < this.y + this.height && (this.y = c, this.height = e);
    } else if (this.selectedPoint === 'Top_Right') {
      d = this.selectedSize.width + a.dx;
      c = this.selectedLocation.y + a.dy;
      c < this.y + this.height && (this.y = c, this.height = this.selectedSize.height - a.dy);
      d > 1 && (this.width = d);
    } else if (this.selectedPoint === 'Middle_Left') {
      d = this.selectedSize.width - a.dx;
      b = this.selectedLocation.x + a.dx;
      b < this.x + this.width && (this.x = b);
      d > 1 && (this.width = d);
    } else if (this.selectedPoint === 'Middle_Right') {
      d = this.selectedSize.width + a.dx;
      d > 1 && (this.width = d);
    } else if (this.selectedPoint === 'Bottom_Left') {
      d = this.selectedSize.width - a.dx;
      b = this.selectedLocation.x + a.dx;
      d > 1 && (this.x = b, this.width = d);
      e = this.selectedSize.height + a.dy;
      e > 1 && (this.height = e);
    } else if (this.selectedPoint === 'Bottom_Center') {
      e = this.selectedSize.height + a.dy;
      e > 1 && (this.height = e);
    } else if (this.selectedPoint === 'Bottom_Right') {
      d = this.selectedSize.width + a.dx;
      d > 1 && (this.width = d);
      e = this.selectedSize.height + a.dy;
      e > 1 && (this.height = e);
    }
    this.dispatchEvent('resize', a);
  }
};

const Images = {};

function Node(text) {
  this.initialize(text);
}

util.extend(Node, EditableElement);
Object.defineProperties(Node.prototype, {
  alarmColor: {
    get: function () {
      return this._alarmColor
    },
    set: function (b) {
      this._alarmColor = b;
      if (this.image != null) {
        const c = util.genImageAlarm(this.image, b);
        c && (this.alarmImage = c);
      }
    }
  }
});

Node.prototype.initialize = function (text) {
  Node.super.initialize.apply(this, arguments);
  this.elementType = 'node';
  this.zIndex = defaultZIndex.node;
  this.text = text;
  this.font = '12px Consolas';
  this.fontColor = '255,255,255';
  this.borderWidth = 0;
  this.borderColor = '255,255,255';
  this.borderRadius = null;
  this.dragable = true;
  this.textPosition = 'Bottom_Center';
  this.textOffsetX = 0;
  this.textOffsetY = 0;
  this.transformAble = true;
  this.inLinks = null;
  this.outLinks = null;
  const d = 'text,font,fontColor,textPosition,textOffsetX,textOffsetY,borderRadius'.split(',');
  this.serializedProperties = this.serializedProperties.concat(d);
};
Node.prototype.paint = function (a) {
  if (this.image) {
    const b = a.globalAlpha;
    a.globalAlpha = this.alpha;
    this.alarmImage != null && this.alarm != null ? a.drawImage(this.alarmImage, -this.width / 2, -this.height / 2, this.width, this.height) : a.drawImage(this.image, -this.width / 2, -this.height / 2, this.width, this.height);
    a.globalAlpha = b;
  } else {
    a.beginPath();
    a.fillStyle = 'rgba(' + this.fillColor + ',' + this.alpha + ')';
    this.borderRadius == null || this.borderRadius === 0 ? a.rect(-this.width / 2, -this.height / 2, this.width, this.height) : a.JTopoRoundRect(-this.width / 2, -this.height / 2, this.width, this.height, this.borderRadius);
    a.fill();
    a.closePath();
  }
  this.paintText(a);
  this.paintBorder(a);
  this.paintCtrl(a);
  this.paintAlarmText(a);
};
Node.prototype.paintAlarmText = function (a) {
  if (!this.alarm) {
    return
  }
  const b = this.alarmColor || '255,0,0';
  const c = this.alarmAlpha || 0.5;
  a.beginPath();
  a.font = this.alarmFont || '10px 微软雅黑';
  const d = a.measureText(this.alarm).width + 6;
  const e = a.measureText('田').width + 6;
  const f = this.width / 2 - d / 2;
  const g = -this.height / 2 - e - 8;
  a.strokeStyle = 'rgba(' + b + ', ' + c + ')';
  a.fillStyle = 'rgba(' + b + ', ' + c + ')';
  a.lineCap = 'round';
  a.lineWidth = 1;
  a.moveTo(f, g);
  a.lineTo(f + d, g);
  a.lineTo(f + d, g + e);
  a.lineTo(f + d / 2 + 6, g + e);
  a.lineTo(f + d / 2, g + e + 8);
  a.lineTo(f + d / 2 - 6, g + e);
  a.lineTo(f, g + e);
  a.lineTo(f, g);
  a.fill();
  a.stroke();
  a.closePath();
  a.beginPath();
  a.strokeStyle = 'rgba(' + this.fontColor + ', ' + this.alpha + ')';
  a.fillStyle = 'rgba(' + this.fontColor + ', ' + this.alpha + ')';
  a.fillText(this.alarm, f + 2, g + e - 4);
  a.closePath();
};
Node.prototype.paintText = function (a) {
  const b = this.text;
  if (!b) {
    return
  }

  a.beginPath();
  a.font = this.font;
  const c = a.measureText(b).width;
  const d = a.measureText('田').width;
  a.fillStyle = 'rgba(' + this.fontColor + ', ' + this.alpha + ')';
  const e = this.getTextPostion(this.textPosition, c, d);
  a.fillText(b, e.x, e.y);
  a.closePath();
};
Node.prototype.paintBorder = function (a) {
  if (!this.borderWidth) {
    return
  }
  a.beginPath();
  a.lineWidth = this.borderWidth;
  a.strokeStyle = 'rgba(' + this.borderColor + ',' + this.alpha + ')';
  const b = this.borderWidth / 2;
  this.borderRadius == null || this.borderRadius === 0 ? a.rect(-this.width / 2 - b, -this.height / 2 - b, this.width + this.borderWidth, this.height + this.borderWidth) : a.JTopoRoundRect(-this.width / 2 - b, -this.height / 2 - b, this.width + this.borderWidth, this.height + this.borderWidth, this.borderRadius);
  a.stroke();
  a.closePath();
};
Node.prototype.getTextPostion = function (a, b, c) {
  let d = null;
  a == null || a === 'Bottom_Center' ? d = {
    x: -this.width / 2 + (this.width - b) / 2,
    y: this.height / 2 + c
  }
    : a === 'Top_Center' ? d = {
      x: -this.width / 2 + (this.width - b) / 2,
      y: -this.height / 2 - c / 2
    }
      : a === 'Top_Right' ? d = {
        x: this.width / 2,
        y: -this.height / 2 - c / 2
      }
        : a === 'Top_Left' ? d = {
          x: -this.width / 2 - b,
          y: -this.height / 2 - c / 2
        }
          : a === 'Bottom_Right' ? d = {
            x: this.width / 2,
            y: this.height / 2 + c
          }
            : a === 'Bottom_Left' ? d = {
              x: -this.width / 2 - b,
              y: this.height / 2 + c
            }
              : a === 'Middle_Center' ? d = {
                x: -this.width / 2 + (this.width - b) / 2,
                y: c / 2
              }
                : a === 'Middle_Right' ? d = {
                  x: this.width / 2,
                  y: c / 2
                }
                  : a === 'Middle_Left' && (d = {
                    x: -this.width / 2 - b,
                    y: c / 2
                  });
  this.textOffsetX != null && (d.x += this.textOffsetX);
  this.textOffsetY != null && (d.y += this.textOffsetY);
  return d
};
Node.prototype.setImage = function (a, b) {
  if (a == null) { throw new Error('Node.setImage(): 参数Image对象为空!') }
  const c = this;
  if (typeof a === 'string') {
    let d = Images[a];
    d == null ? (d = new window.Image(), d.src = a, d.onload = function () {
      Images[a] = d;
      b && c.setSize(d.width, d.height);
      c.image = d;
      c.alarmColor = c.alarmColor == null ? '255,0,0' : c.alarmColor;
    }) : (b && this.setSize(d.width, d.height), c.image = d, c.alarmColor = c.alarmColor == null ? '255,0,0' : c.alarmColor);
  } else {
    this.image = a;
    c.alarmColor = c.alarmColor == null ? '255,0,0' : c.alarmColor;
    b && this.setSize(a.width, a.height);
  }
};
Node.prototype.removeHandler = function (a) {
  const b = this;
  this.outLinks && (this.outLinks.forEach(function (c) {
    c.nodeA === b && a.remove(c);
  }), this.outLinks = null);
  this.inLinks && (this.inLinks.forEach(function (c) {
    c.nodeZ === b && a.remove(c);
  }), this.inLinks = null);
};

function SelectArea(a, b, c, d) {
  return function (e) {
    e.beginPath();
    e.strokeStyle = 'rgba(0,0,236,0.5)';
    e.fillStyle = 'rgba(0,0,236,0.1)';
    e.rect(a, b, c, d);
    e.fill();
    e.stroke();
    e.closePath();
  }
}

function Scene(c) {
  this.initialize();
  c != null && (c.add(this), this.addTo(c));

  this.touchstart = this.mousedownHander;
  this.touchmove = this.mousedragHandler;
  this.touchend = this.mousedownHander;
  const f = 'click,dbclick,mousedown,mouseup,mouseover,mouseout,mousemove,mousedrag,mousewheel,touchstart,touchmove,touchend,keydown,keyup'.split(',');
  f.forEach((a) => {
    this[a] = function (b) {
      b != null ? this.addEventListener(a, b) : this.dispatchEvent(a);
    };
  });
}

util.extend(Scene, Element);

Scene.prototype.initialize = function () {
  Scene.super.initialize.apply(this, arguments);
  this.messageBus = new util.MessageBus();
  this.elementType = 'scene';
  this.childs = [];
  this.zIndexMap = {};
  this.zIndexArray = [];
  this.backgroundColor = '255,255,255';
  this.visible = true;
  this.alpha = 0;
  this.scaleX = 1;
  this.scaleY = 1;
  this.mode = SceneMode.normal;
  this.translate = true;
  this.translateX = 0;
  this.translateY = 0;
  this.lastTranslateX = 0;
  this.lastTranslateY = 0;
  this.mouseDown = false;
  this.mouseDownX = null;
  this.mouseDownY = null;
  this.mouseDownEvent = null;
  this.areaSelect = true;
  this.operations = [];
  this.selectedElements = [];
  this.paintAll = false;

  const c = 'background,backgroundColor,mode,paintAll,areaSelect,translate,translateX,translateY,lastTranslatedX,lastTranslatedY,alpha,visible,scaleX,scaleY'.split(',');
  this.serializedProperties = this.serializedProperties.concat(c);
};

Scene.prototype.setBackground = function (a) {
  this.background = a;
};

Scene.prototype.addTo = function (a) {
  this.stage !== a && a != null && (this.stage = a);
};

Scene.prototype.show = function () {
  this.visible = true;
};

Scene.prototype.hide = function () {
  this.visible = false;
};

Scene.prototype.paint = function (a) {
  if (this.visible && this.stage) {
    a.save();
    this.paintBackgroud(a);
    a.restore();
    a.save();
    a.scale(this.scaleX, this.scaleY);
    if (this.translate === 1) {
      const b = this.getOffsetTranslate(a);
      a.translate(b.translateX, b.translateY);
    }
    this.paintChilds(a);
    a.restore();
    a.save();
    this.paintOperations(a, this.operations);
    a.restore();
  }
};

Scene.prototype.repaint = function (a) {
  this.visible && this.paint(a);
};

Scene.prototype.paintBackgroud = function (a) {
  this.background != null ? a.drawImage(this.background, 0, 0, a.canvas.width, a.canvas.height) : (a.beginPath(), a.fillStyle = 'rgba(' + this.backgroundColor + ',' + this.alpha + ')', a.fillRect(0, 0, a.canvas.width, a.canvas.height), a.closePath());
};

Scene.prototype.getDisplayedElements = function () {
  const a = [];
  for (let b = 0; b < this.zIndexArray.length; b++) {
    for (let c = this.zIndexArray[b], d = this.zIndexMap[c], e = 0; e < d.length; e++) {
      const f = d[e];
      this.isVisiable(f) && a.push(f);
    }
  }
  return a
};

Scene.prototype.getDisplayedNodes = function () {
  const b = [];
  for (let c = 0; c < this.childs.length; c++) {
    const d = this.childs[c];
    d instanceof Node && this.isVisiable(d) && b.push(d);
  }
  return b
};

Scene.prototype.paintChilds = function (b) {
  for (let c = 0; c < this.zIndexArray.length; c++) {
    for (let d = this.zIndexArray[c], e = this.zIndexMap[d], f = 0; f < e.length; f++) {
      const g = e[f];
      if (this.paintAll === true || this.isVisiable(g)) {
        b.save();
        if (g.transformAble === true) {
          const h = g.getCenterLocation();
          b.translate(h.x, h.y);
          g.rotate && b.rotate(g.rotate);
          g.scaleX && g.scaleY ? b.scale(g.scaleX, g.scaleY) : g.scaleX ? b.scale(g.scaleX, 1) : g.scaleY && b.scale(1, g.scaleY);
        }
        g.shadow === true && (b.shadowBlur = g.shadowBlur, b.shadowColor = g.shadowColor, b.shadowOffsetX = g.shadowOffsetX, b.shadowOffsetY = g.shadowOffsetY);
        g instanceof InteractiveElement && (g.selected && g.showSelected === true && g.paintSelected(b), g.isMouseOver === true && g.paintMouseover(b));
        g.paint(b);
        b.restore();
      }
    }
  }
};

Scene.prototype.getOffsetTranslate = function (a) {
  let b = this.stage.canvas.width;
  let c = this.stage.canvas.height;
  a && a !== 'move' && (b = a.canvas.width, c = a.canvas.height);
  const d = b / this.scaleX / 2;
  const e = c / this.scaleY / 2;
  const f = {
    translateX: this.translateX + (d - d * this.scaleX),
    translateY: this.translateY + (e - e * this.scaleY)
  };
  return f
};

Scene.prototype.isVisiable = function (b) {
  if (b.visible === false) {
    return false
  }
  if (b instanceof Link) {
    return true
  }
  const c = this.getOffsetTranslate();
  let d = b.x + c.translateX;
  let e = b.y + c.translateY;
  d *= this.scaleX;
  e *= this.scaleY;
  const f = d + b.width * this.scaleX;
  const g = e + b.height * this.scaleY;
  return !(d > this.stage.canvas.width || e > this.stage.canvas.height || f < 0 || g < 0)
};

Scene.prototype.paintOperations = function (a, b) {
  for (let c = 0; c < b.length; c++) { b[c](a); }
};

Scene.prototype.findElements = function (a) {
  const b = [];
  for (let c = 0; c < this.childs.length; c++) {
    a(this.childs[c]) && b.push(this.childs[c]);
  }
  return b
};

Scene.prototype.getElementsByClass = function (a) {
  return this.findElements(function (b) {
    return b instanceof a
  })
};

Scene.prototype.addOperation = function (a) {
  this.operations.push(a);
  return this
};

Scene.prototype.clearOperations = function () {
  this.operations = [];
  return this
};

Scene.prototype.getElementByXY = function (b, c) {
  let d = null;
  for (let e = this.zIndexArray.length - 1; e >= 0; e--) {
    for (let f = this.zIndexArray[e], g = this.zIndexMap[f], h = g.length - 1; h >= 0; h--) {
      const i = g[h];
      if (i instanceof InteractiveElement && this.isVisiable(i) && i.isInBound(b, c)) {
        d = i;
        return d
      }
    }
  }
  return d
};

Scene.prototype.add = function (a) {
  this.childs.push(a);
  this.zIndexMap[a.zIndex] == null && (this.zIndexMap[a.zIndex] = [], this.zIndexArray.push(a.zIndex), this.zIndexArray.sort(function (a, b) {
    return a - b
  }));
  this.zIndexMap['' + a.zIndex].push(a);
};

Scene.prototype.remove = function (b) {
  this.childs = util.removeFromArray(this.childs, b);
  const c = this.zIndexMap[b.zIndex];
  c && (this.zIndexMap[b.zIndex] = util.removeFromArray(c, b));
  b.removeHandler(this);
};

Scene.prototype.clear = function () {
  const a = this;
  this.childs.forEach(function (b) {
    b.removeHandler(a);
  });
  this.childs = [];
  this.operations = [];
  this.zIndexArray = [];
  this.zIndexMap = {};
};

Scene.prototype.addToSelected = function (a) {
  this.selectedElements.push(a);
};

Scene.prototype.cancleAllSelected = function (a) {
  for (let b = 0; b < this.selectedElements.length; b++) { this.selectedElements[b].unselectedHandler(a); }
  this.selectedElements = [];
};

Scene.prototype.notInSelectedNodes = function (a) {
  for (let b = 0; b < this.selectedElements.length; b++) {
    if (a === this.selectedElements[b]) { return false }
  }
  return true
};

Scene.prototype.removeFromSelected = function (a) {
  for (let b = 0; b < this.selectedElements.length; b++) {
    const c = this.selectedElements[b];
    a === c && (this.selectedElements = this.selectedElements.del(b));
  }
};

Scene.prototype.toSceneEvent = function (b) {
  const c = util.clone(b);
  c.x /= this.scaleX;
  c.y /= this.scaleY;
  if (this.translate === true) {
    const d = this.getOffsetTranslate();
    c.x -= d.translateX;
    c.y -= d.translateY;
  }

  c.dx != null && (c.dx /= this.scaleX, c.dy /= this.scaleY);
  this.currentElement != null && (c.target = this.currentElement);
  c.scene = this;
  return c
};

Scene.prototype.selectElement = function (a) {
  const b = this.getElementByXY(a.x, a.y);
  if (b != null) {
    a.target = b;
    b.mousedownHander(a);
    b.selectedHandler(a);
    if (this.notInSelectedNodes(b)) {
      a.ctrlKey || this.cancleAllSelected();
      this.addToSelected(b);
    } else {
      a.ctrlKey && (b.unselectedHandler(), this.removeFromSelected(b));
      for (let c = 0; c < this.selectedElements.length; c++) {
        const d = this.selectedElements[c];
        d.selectedHandler(a);
      }
    }
  } else { a.ctrlKey || this.cancleAllSelected(); }
  this.currentElement = b;
};

Scene.prototype.mousedownHandler = function (b) {
  const c = this.toSceneEvent(b);
  this.mouseDown = true;
  this.mouseDownX = c.x;
  this.mouseDownY = c.y;
  this.mouseDownEvent = c;
  if (this.mode === SceneMode.normal) {
    this.selectElement(c);

    (this.currentElement == null || this.currentElement instanceof Link) && this.translate && (this.lastTranslateX = this.translateX, this.lastTranslateY = this.translateY);
  } else {
    if (this.mode === SceneMode.drag && this.translate) {
      this.lastTranslateX = this.translateX;
      this.lastTranslateY = this.translateY;
      return
    }
    this.mode === SceneMode.select ? this.selectElement(c) : this.mode === SceneMode.edit && (this.selectElement(c), (this.currentElement == null || this.currentElement instanceof Link) && this.translate && (this.lastTranslateX = this.translateX, this.lastTranslateY = this.translateY));
  }
  this.dispatchEvent('mousedown', c);
};

Scene.prototype.mouseupHandler = function (b) {
  this.stage.cursor !== MouseCursor.normal && (this.stage.cursor = MouseCursor.normal);
  this.clearOperations();
  const c = this.toSceneEvent(b);
  this.currentElement != null && (c.target = this.currentElement, this.currentElement.mouseupHandler(c));
  this.dispatchEvent('mouseup', c);
  this.mouseDown = false;
};

Scene.prototype.dragElements = function (b) {
  if (this.currentElement != null && this.currentElement.dragable) {
    for (let c = 0; c < this.selectedElements.length; c++) {
      const d = this.selectedElements[c];
      if (d.dragable) {
        const e = util.clone(b);
        e.target = d;
        d.mousedragHandler(e);
      }
    }
  }
};

Scene.prototype.mousedragHandler = function (b) {
  const c = this.toSceneEvent(b);
  this.mode === SceneMode.normal ? this.currentElement == null || this.currentElement instanceof Link ? this.translate === true && (this.stage.cursor = MouseCursor.closed_hand, this.translateX = this.lastTranslateX + c.dx, this.translateY = this.lastTranslateY + c.dy) : this.dragElements(c) : this.mode === SceneMode.drag ? this.translate === true && (this.stage.cursor = MouseCursor.closed_hand, this.translateX = this.lastTranslateX + c.dx, this.translateY = this.lastTranslateY + c.dy) : this.mode === SceneMode.select ? this.currentElement != null ? this.currentElement.dragable === true && this.dragElements(c) : this.areaSelect === true && this.areaSelectHandle(c) : this.mode === SceneMode.edit && (this.currentElement == null || this.currentElement instanceof Link ? this.translate === true && (this.stage.cursor = MouseCursor.closed_hand, this.translateX = this.lastTranslateX + c.dx, this.translateY = this.lastTranslateY + c.dy) : this.dragElements(c));
  this.dispatchEvent('mousedrag', c);
};

Scene.prototype.areaSelectHandle = function (a) {
  let b = a.offsetLeft;
  let c = a.offsetTop;
  let f = this.mouseDownEvent.offsetLeft;
  let g = this.mouseDownEvent.offsetTop;
  let h = b >= f ? f : b;
  let i = c >= g ? g : c;
  let j = Math.abs(a.dx) * this.scaleX;
  let k = Math.abs(a.dy) * this.scaleY;
  const l = new SelectArea(h, i, j, k);
  this.clearOperations().addOperation(l);
  b = a.x;
  c = a.y;
  f = this.mouseDownEvent.x;
  g = this.mouseDownEvent.y;
  h = b >= f ? f : b;
  i = c >= g ? g : c;
  j = Math.abs(a.dx);
  k = Math.abs(a.dy);
  const m = h + j;
  const n = i + k;
  for (let o = 0; o < this.childs.length; o++) {
    const p = this.childs[o];
    p.x > h && p.x + p.width < m && p.y > i && p.y + p.height < n && this.notInSelectedNodes(p) && (p.selectedHandler(a), this.addToSelected(p));
  }
};

Scene.prototype.mousemoveHandler = function (b) {
  this.mousecoord = {
    x: b.x,
    y: b.y
  };
  const c = this.toSceneEvent(b);
  if (this.mode === SceneMode.drag) { return void (this.stage.cursor = MouseCursor.open_hand) }
  this.mode === SceneMode.normal ? this.stage.cursor = MouseCursor.normal : this.mode === SceneMode.select && (this.stage.cursor = MouseCursor.normal);
  const d = this.getElementByXY(c.x, c.y);
  d ? (this.mouseOverelement && this.mouseOverelement !== d && (c.target = d, this.mouseOverelement.mouseoutHandler(c)), this.mouseOverelement = d, d.isMouseOver === true ? (c.target = d, d.mouseoverHandler(c), this.dispatchEvent('mouseover', c)) : (c.target = d, d.mousemoveHandler(c), this.dispatchEvent('mousemove', c))) : this.mouseOverelement ? (c.target = d, this.mouseOverelement.mouseoutHandler(c), this.mouseOverelement = null, this.dispatchEvent('mouseout', c)) : (c.target = null, this.dispatchEvent('mousemove', c));
};

Scene.prototype.mouseoverHandler = function (a) {
  const b = this.toSceneEvent(a);
  this.dispatchEvent('mouseover', b);
};

Scene.prototype.mouseoutHandler = function (a) {
  const b = this.toSceneEvent(a);
  this.dispatchEvent('mouseout', b);
};

Scene.prototype.clickHandler = function (a) {
  const b = this.toSceneEvent(a);
  this.currentElement && (b.target = this.currentElement, this.currentElement.clickHandler(b));
  this.dispatchEvent('click', b);
};

Scene.prototype.dbclickHandler = function (a) {
  const b = this.toSceneEvent(a);
  this.currentElement ? (b.target = this.currentElement, this.currentElement.dbclickHandler(b)) : this.cancleAllSelected();
  this.dispatchEvent('dbclick', b);
};

Scene.prototype.mousewheelHandler = function (a) {
  const b = this.toSceneEvent(a);
  this.dispatchEvent('mousewheel', b);
};

Scene.prototype.keydownHandler = function (a) {
  this.dispatchEvent('keydown', a);
};

Scene.prototype.keyupHandler = function (a) {
  this.dispatchEvent('keyup', a);
};

Scene.prototype.addEventListener = function (a, b) {
  const c = this;
  const d = function (a) {
    b.call(c, a);
  };
  this.messageBus.subscribe(a, d);
  return this
};
Scene.prototype.removeEventListener = function (a) {
  this.messageBus.unsubscribe(a);
};

Scene.prototype.removeAllEventListener = function () {
  this.messageBus = new util.MessageBus();
};

Scene.prototype.dispatchEvent = function (a, b) {
  this.messageBus.publish(a, b);
  return this
};

Scene.prototype.zoom = function (a, b) {
  a != null && a !== 0 && (this.scaleX = a);
  b != null && b !== 0 && (this.scaleY = b);
};

Scene.prototype.zoomOut = function (a) {
  a !== 0 && (a == null && (a = 0.8), this.scaleX /= a, this.scaleY /= a);
};

Scene.prototype.zoomIn = function (a) {
  a !== 0 && (a == null && (a = 0.8), this.scaleX *= a, this.scaleY *= a);
};

Scene.prototype.getBound = function () {
  return {
    left: 0,
    top: 0,
    right: this.stage.canvas.width,
    bottom: this.stage.canvas.height,
    width: this.stage.canvas.width,
    height: this.stage.canvas.height
  }
};

Scene.prototype.getElementsBound = function () {
  return util.getElementsBound(this.childs)
};

Scene.prototype.translateToCenter = function (a) {
  const b = this.getElementsBound();
  let c = this.stage.canvas.width / 2 - (b.left + b.right) / 2;
  let d = this.stage.canvas.height / 2 - (b.top + b.bottom) / 2;
  a && (c = a.canvas.width / 2 - (b.left + b.right) / 2, d = a.canvas.height / 2 - (b.top + b.bottom) / 2);
  this.translateX = c;
  this.translateY = d;
};

Scene.prototype.setCenter = function (a, b) {
  const c = a - this.stage.canvas.width / 2;
  const d = b - this.stage.canvas.height / 2;
  this.translateX = -c;
  this.translateY = -d;
};

Scene.prototype.centerAndZoom = function (a, b, c) {
  this.translateToCenter(c);
  if (a == null || b == null) {
    const d = this.getElementsBound();
    const e = d.right - d.left;
    const f = d.bottom - d.top;
    let g = this.stage.canvas.width / e;
    let h = this.stage.canvas.height / f;
    c && (g = c.canvas.width / e, h = c.canvas.height / f);
    const i = Math.min(g, h);
    if (i > 1) {
      return
    }
    this.zoom(i, i);
  }
  this.zoom(a, b);
};

Scene.prototype.getCenterLocation = function () {
  return {
    x: this.stage.canvas.width / 2,
    y: this.stage.canvas.height / 2
  }
};

Scene.prototype.doLayout = function (a) {
  a && a(this, this.childs);
};

Scene.prototype.toJson = function () {
  let b = '{';
  this.serializedProperties.length;
  this.serializedProperties.forEach((c) => {
    let d = this[c];
    c === 'background' && (d = this._background.src);
    typeof d === 'string' && (d = '"' + d + '"');
    b += '"' + c + '":' + d + ',';
  });
  b += '"childs":[';
  const c = this.childs.length;
  this.childs.forEach((a, d) => {
    b += a.toJson();
    c > d + 1 && (b += ',');
  });
  b += ']';
  b += '}';
  return b
};

Scene.prototype.find = find;

const c = {};

Object.defineProperties(Scene.prototype, {
  background: {
    get: function () {
      return this._background
    },
    set: function (a) {
      if (typeof a === 'string') {
        let b = c[a];
        b == null && (b = new window.Image(), b.src = a, b.onload = function () {
          c[a] = b;
        });
        this._background = b;
      } else {
        this._background = a;
      }
    }
  }
});

const noop = a => a;

let e = 'click,mousedown,mouseup,mouseover,mouseout,mousedrag,keydown,keyup'.split(',');

function b(a, b) {
  let c = [];
  if (a.length === 0) { return c }
  let d = b.match(/^\s*(\w+)\s*$/);
  if (d != null) {
    const e = a.filter(function (a) {
      return a.elementType === d[1]
    });
    e != null && e.length > 0 && (c = c.concat(e));
  } else {
    let f = false;
    d = b.match(/\s*(\w+)\s*\[\s*(\w+)\s*([>=<])\s*['"](\S+)['"]\s*\]\s*/);
    if (d == null || d.length < 5) {
      d = b.match(/\s*(\w+)\s*\[\s*(\w+)\s*([>=<])\s*(\d+(\.\d+)?)\s*\]\s*/);
      f = true;
    }
    if (d != null && d.length >= 5) {
      const g = d[1];
      const h = d[2];
      const i = d[3];
      const j = d[4];
      e = a.filter(function (a) {
        if (a.elementType !== g) { return false }
        let b = a[h];
        f && (b = parseInt(b));
        return i === '=' ? b === j : i === '>' ? b > j : i === '<' ? j > b : i === '<=' ? j >= b : i === '>=' ? b >= j : i === '!=' ? b !== j : false
      });
      e != null && e.length > 0 && (c = c.concat(e));
    }
  }
  return c
}
function c$1(a) {
  a.find = function (a) {
    return find.call(this, a)
  };
  e.forEach(function (b) {
    a[b] = function (a) {
      for (let c = 0; c < this.length; c++) { this[c][b](a); }
      return this
    };
  });
  if (a.length > 0) {
    const b = a[0];
    for (const c in b) {
      const f = b[c];
      typeof f === 'function' && !(function (b) {
        a[c] = function () {
          for (let c = [], d = 0; d < a.length; d++) { c.push(b.apply(a[d], arguments)); }
          return c
        };
      }(f));
    }
  }
  a.attr = function (a, b) {
    let c, d, e;
    if (a != null && b != null) {
      for (c = 0; c < this.length; c++) { this[c][a] = b; }
    } else {
      if (a != null && typeof a === 'string') {
        for (d = [], c = 0; c < this.length; c++) { d.push(this[c][a]); }
        return d
      }
      if (a != null) {
        for (c = 0; c < this.length; c++) {
          for (e in a) { this[c][e] = a[e]; }
        }
      }
    }
    return this
  };
  return a
}

const find = function find(d) {
  let e = [];
  let f = [];
  this instanceof Stage ? (e = this.childs, f = f.concat(e)) : this instanceof Scene ? e = [this] : f = this;
  e.forEach(function (a) {
    f = f.concat(a.childs);
  });
  let g = null;
  g = typeof d === 'function' ? f.filter(d) : b(f, d);
  return c$1(g)
};

function Element() {
}

Element.prototype.initialize = function () {
  this.elementType = 'element';
  this.serializedProperties = ['elementType'];
  this.propertiesStack = [];
  this._id = '' + (new Date()).getTime();
};

Element.prototype.distroy = noop;
Element.prototype.removeHandler = noop;

Element.prototype.attr = function (a, b) {
  if (a != null && b != null) { this[a] = b; } else if (a != null) { return this[a] }
  return this
};

Element.prototype.save = function () {
  const a = this;
  const b = {};
  this.serializedProperties.forEach(function (c) {
    b[c] = a[c];
  });
  this.propertiesStack.push(b);
};

Element.prototype.restore = function () {
  if (this.propertiesStack != null && this.propertiesStack.length !== 0) {
    const a = this;
    const b = this.propertiesStack.pop();
    this.serializedProperties.forEach(function (c) {
      a[c] = b[c];
    });
  }
};

Element.prototype.toJson = function () {
  const a = this;
  const c = this.serializedProperties.length;
  let b = '';

  this.serializedProperties.forEach((d, e) => {
    let f = a[d];
    typeof f === 'string' && (f = '"' + f + '"');
    b += '"' + d + '":' + f;
    c > e + 1 && (b += ',');
  });

  return `{${b}}`
};

function DisplayElement() {
  this.initialize();
}

util.extend(DisplayElement, Element);

Object.defineProperties(DisplayElement.prototype, {
  cx: {
    get: function () {
      return this.x + this.width / 2
    },
    set: function (a) {
      this.x = a - this.width / 2;
    }
  },
  cy: {
    get: function () {
      return this.y + this.height / 2
    },
    set: function (a) {
      this.y = a - this.height / 2;
    }
  }
});

DisplayElement.prototype.initialize = function () {
  DisplayElement.super.initialize.apply(this, arguments);
  this.elementType = 'displayElement';
  this.x = 0;
  this.y = 0;
  this.width = 32;
  this.height = 32;
  this.visible = true;
  this.alpha = 1;
  this.rotate = 0;
  this.scaleX = 1;
  this.scaleY = 1;
  this.strokeColor = '22,124,255';
  this.borderColor = '22,124,255';
  this.fillColor = '22,124,255';
  this.shadow = false;
  this.shadowBlur = 5;
  this.shadowColor = 'rgba(0,0,0,0.5)';
  this.shadowOffsetX = 3;
  this.shadowOffsetY = 6;
  this.transformAble = false;
  this.zIndex = 0;
  const a = 'x,y,width,height,visible,alpha,rotate,scaleX,scaleY,strokeColor,fillColor,shadow,shadowColor,shadowOffsetX,shadowOffsetY,transformAble,zIndex'.split(',');
  this.serializedProperties = this.serializedProperties.concat(a);
};
DisplayElement.prototype.paint = function (a) {
  a.beginPath();
  a.fillStyle = 'rgba(' + this.fillColor + ',' + this.alpha + ')';
  a.rect(-this.width / 2, -this.height / 2, this.width, this.height);
  a.fill();
  a.stroke();
  a.closePath();
};
DisplayElement.prototype.getLocation = function () {
  return {
    x: this.x,
    y: this.y
  }
};
DisplayElement.prototype.setLocation = function (a, b) {
  this.x = a;
  this.y = b;
  return this
};
DisplayElement.prototype.getCenterLocation = function () {
  return {
    x: this.x + this.width / 2,
    y: this.y + this.height / 2
  }
};
DisplayElement.prototype.setCenterLocation = function (a, b) {
  this.x = a - this.width / 2;
  this.y = b - this.height / 2;
  return this
};
DisplayElement.prototype.getSize = function () {
  return {
    width: this.width,
    height: this.heith
  }
};
DisplayElement.prototype.setSize = function (a, b) {
  this.width = a;
  this.height = b;
  return this
};
DisplayElement.prototype.getBound = function () {
  return {
    left: this.x,
    top: this.y,
    right: this.x + this.width,
    bottom: this.y + this.height,
    width: this.width,
    height: this.height
  }
};
DisplayElement.prototype.setBound = function (a, b, c, d) {
  this.setLocation(a, b);
  this.setSize(c, d);
  return this
};
DisplayElement.prototype.getDisplayBound = function () {
  return {
    left: this.x,
    top: this.y,
    right: this.x + this.width * this.scaleX,
    bottom: this.y + this.height * this.scaleY
  }
};
DisplayElement.prototype.getDisplaySize = function () {
  return {
    width: this.width * this.scaleX,
    height: this.height * this.scaleY
  }
};
DisplayElement.prototype.getPosition = function (a) {
  let b;
  const c = this.getBound();

  switch (a) {
    case 'Top_Left':
      b = {
        x: c.left,
        y: c.top
      };
      break
    case 'Top_Center':
      b = {
        x: this.cx,
        y: c.top
      };
      break
    case 'Top_Right':
      b = {
        x: c.right,
        y: c.top
      };
      break
    case 'Middle_Left':
      b = {
        x: c.left,
        y: this.cy
      };
      break
    case 'Middle_Center':
      b = {
        x: this.cx,
        y: this.cy
      };
      break
    case 'Middle_Right':
      b = {
        x: c.right,
        y: this.cy
      };
      break
    case 'Bottom_Center':
      b = {
        x: this.cx,
        y: c.bottom
      };
      break
    case 'Bottom_Right':
      b = {
        x: c.right,
        y: c.bottom
      };
      break
  }

  return b
};

function InteractiveElement() {
  this.initialize();
  const b = 'click,dbclick,mousedown,mouseup,mouseover,mouseout,mousemove,mousedrag,touchstart,touchmove,touchend'.split(',');
  b.forEach((a) => {
    this[a] = function (b) {
      b != null ? this.addEventListener(a, b) : this.dispatchEvent(a);
    };
  });
}

util.extend(InteractiveElement, DisplayElement);

InteractiveElement.prototype.initialize = function () {
  InteractiveElement.super.initialize.apply(this, arguments);
  this.elementType = 'interactiveElement';
  this.dragable = true;
  this.selected = true;
  this.showSelected = true;
  this.selectedLocation = null;
  this.isMouseOver = true;
  const a = 'dragable,selected,showSelected,isMouseOver'.split(',');
  this.serializedProperties = this.serializedProperties.concat(a);
};
InteractiveElement.prototype.paintSelected = function (a) {
  this.showSelected && (a.save(), a.beginPath(), a.strokeStyle = 'rgba(168,202,255, 0.9)', a.fillStyle = 'rgba(168,202,236,0.7)', a.rect(-this.width / 2 - 3, -this.height / 2 - 3, this.width + 6, this.height + 6), a.fill(), a.stroke(), a.closePath(), a.restore());
};
InteractiveElement.prototype.paintMouseover = function (a) {
  return this.paintSelected(a)
};
InteractiveElement.prototype.isInBound = function (a, b) {
  return a > this.x && a < this.x + this.width * Math.abs(this.scaleX) && b > this.y && b < this.y + this.height * Math.abs(this.scaleY)
};
InteractiveElement.prototype.selectedHandler = function () {
  this.selected = true;
  this.selectedLocation = {
    x: this.x,
    y: this.y
  };
};
InteractiveElement.prototype.unselectedHandler = function () {
  this.selected = true;
  this.selectedLocation = null;
};
InteractiveElement.prototype.dbclickHandler = function (a) {
  this.dispatchEvent('dbclick', a);
};
InteractiveElement.prototype.clickHandler = function (a) {
  this.dispatchEvent('click', a);
};
InteractiveElement.prototype.mousedownHander = function (a) {
  this.dispatchEvent('mousedown', a);
};
InteractiveElement.prototype.mouseupHandler = function (a) {
  this.dispatchEvent('mouseup', a);
};
InteractiveElement.prototype.mouseoverHandler = function (a) {
  this.isMouseOver = true;
  this.dispatchEvent('mouseover', a);
};
InteractiveElement.prototype.mousemoveHandler = function (a) {
  this.dispatchEvent('mousemove', a);
};
InteractiveElement.prototype.mouseoutHandler = function (a) {
  this.isMouseOver = true;
  this.dispatchEvent('mouseout', a);
};
InteractiveElement.prototype.mousedragHandler = function (a) {
  const b = this.selectedLocation.x + a.dx;
  const c = this.selectedLocation.y + a.dy;
  this.setLocation(b, c);
  this.dispatchEvent('mousedrag', a);
};
InteractiveElement.prototype.addEventListener = function (b, c) {
  const d = this;
  const e = function (a) {
    c.call(d, a);
  };
  this.messageBus || (this.messageBus = new util.MessageBus());
  this.messageBus.subscribe(b, e);
  return this
};
InteractiveElement.prototype.dispatchEvent = function (a, b) {
  return this.messageBus ? (this.messageBus.publish(a, b), this) : null
};
InteractiveElement.prototype.removeEventListener = function (a) {
  this.messageBus.unsubscribe(a);
};
InteractiveElement.prototype.removeAllEventListener = function () {
  this.messageBus = new util.MessageBus();
};

function b$1(a, b) {
  const c = [];
  if (a == null || b == null) { return c }
  if (a && b && a.outLinks && b.inLinks) {
    for (let d = 0; d < a.outLinks.length; d++) {
      for (let e = a.outLinks[d], f = 0; f < b.inLinks.length; f++) {
        const g = b.inLinks[f];
        e === g && c.push(g);
      }
    }
  }
  return c
}
function c$2(a, c) {
  const d = b$1(a, c);
  const e = b$1(c, a);
  const f = d.concat(e);
  return f
}
function d(a) {
  const b = c$2(a.nodeA, a.nodeZ);
  return b.filter(function (b) {
    return a !== b
  })
}
function e$1(a, b) {
  return c$2(a, b).length
}
function h(b, c) {
  const d = util.lineF(b.cx, b.cy, c.cx, c.cy);
  const e = b.getBound();
  const f = util.intersectionLineBound(d, e);
  return f
}

function Link(b, c, g) {
  this.initialize(b, c, g);
}

util.extend(Link, InteractiveElement);

Link.prototype.initialize = function (nodeA, nodeZ, text) {
  if (arguments.length < 2) {
    throw new Error('')
  }
  Link.super.initialize.apply(this, arguments);
  this.elementType = 'link';
  this.zIndex = defaultZIndex.link;

  this.text = text;
  this.nodeA = nodeA;
  this.nodeZ = nodeZ;
  this.nodeA && this.nodeA.outLinks == null && (this.nodeA.outLinks = []);
  this.nodeA && this.nodeA.inLinks == null && (this.nodeA.inLinks = []);
  this.nodeZ && this.nodeZ.inLinks == null && (this.nodeZ.inLinks = []);
  this.nodeZ && this.nodeZ.outLinks == null && (this.nodeZ.outLinks = []);
  this.nodeA != null && this.nodeA.outLinks.push(this);
  this.nodeZ != null && this.nodeZ.inLinks.push(this);
  this.caculateIndex();
  this.font = '12px Consolas';
  this.fontColor = '255,255,255';
  this.lineWidth = 2;
  this.lineJoin = 'miter';
  this.transformAble = false;
  this.bundleOffset = 20;
  this.bundleGap = 12;
  this.textOffsetX = 0;
  this.textOffsetY = 0;
  this.arrowsRadius = null;
  this.arrowsOffset = 0;
  this.dashedPattern = null;
  this.path = [];
  const e = 'text,font,fontColor,lineWidth,lineJoin'.split(',');
  this.serializedProperties = this.serializedProperties.concat(e);
};
Link.prototype.caculateIndex = function () {
  const a = e$1(this.nodeA, this.nodeZ);
  a > 0 && (this.nodeIndex = a - 1);
};
Link.prototype.removeHandler = function () {
  const a = this;
  this.nodeA && this.nodeA.outLinks && (this.nodeA.outLinks = this.nodeA.outLinks.filter(function (b) {
    return b !== a
  }));
  this.nodeZ && this.nodeZ.inLinks && (this.nodeZ.inLinks = this.nodeZ.inLinks.filter(function (b) {
    return b !== a
  }));
  const b = d(this);
  b.forEach(function (a, b) {
    a.nodeIndex = b;
  });
};
Link.prototype.getStartPosition = function () {
  const a = {
    x: this.nodeA.cx,
    y: this.nodeA.cy
  };
  return a
};
Link.prototype.getEndPosition = function () {
  let a;
  this.arrowsRadius != null && (a = h(this.nodeZ, this.nodeA));
  a == null && (a = {
    x: this.nodeZ.cx,
    y: this.nodeZ.cy
  });
  return a
};
Link.prototype.getPath = function () {
  const a = [];
  const b = this.getStartPosition();
  const c = this.getEndPosition();
  if (this.nodeA === this.nodeZ) {
    return [b, c]
  }
  const d$$1 = e$1(this.nodeA, this.nodeZ);
  // TODO: b array.length  ==
  if (d$$1 === 1) {
    return [b, c]
  }
  const f = Math.atan2(c.y - b.y, c.x - b.x);
  const g = {
    x: b.x + this.bundleOffset * Math.cos(f),
    y: b.y + this.bundleOffset * Math.sin(f)
  };
  const h$$1 = {
    x: c.x + this.bundleOffset * Math.cos(f - Math.PI),
    y: c.y + this.bundleOffset * Math.sin(f - Math.PI)
  };
  const i = f - Math.PI / 2;
  const j = f - Math.PI / 2;
  const k = d$$1 * this.bundleGap / 2 - this.bundleGap / 2;
  const l = this.bundleGap * this.nodeIndex;
  let m = {
    x: g.x + l * Math.cos(i),
    y: g.y + l * Math.sin(i)
  };
  let n = {
    x: h$$1.x + l * Math.cos(j),
    y: h$$1.y + l * Math.sin(j)
  };
  m = {
    x: m.x + k * Math.cos(i - Math.PI),
    y: m.y + k * Math.sin(i - Math.PI)
  };
  n = {
    x: n.x + k * Math.cos(j - Math.PI),
    y: n.y + k * Math.sin(j - Math.PI)
  };
  a.push({
    x: b.x,
    y: b.y
  });
  a.push({
    x: m.x,
    y: m.y
  });
  a.push({
    x: n.x,
    y: n.y
  });
  a.push({
    x: c.x,
    y: c.y
  });
  return a
};
Link.prototype.paintPath = function (a, b) {
  if (this.nodeA === this.nodeZ) { return void this.paintLoop(a) }
  a.beginPath();
  a.moveTo(b[0].x, b[0].y);
  for (let c = 1; c < b.length; c++) {
    this.dashedPattern == null ? a.lineTo(b[c].x, b[c].y) : a.JTopoDashedLineTo(b[c - 1].x, b[c - 1].y, b[c].x, b[c].y, this.dashedPattern);
  }

  a.stroke();
  a.closePath();

  if (this.arrowsRadius != null) {
    const d$$1 = b[b.length - 2];
    const e = b[b.length - 1];
    this.paintArrow(a, d$$1, e);
  }
};
Link.prototype.paintLoop = function (a) {
  a.beginPath();
  const b = this.bundleGap * (this.nodeIndex + 1) / 2;
  Math.PI + Math.PI / 2;
  a.arc(this.nodeA.x, this.nodeA.y, b, Math.PI / 2, 2 * Math.PI);
  a.stroke();
  a.closePath();
};
Link.prototype.paintArrow = function (b, c, d$$1, flag) {
  const e = this.arrowsOffset;
  const f = this.arrowsRadius / 2;
  const g = c;
  const h$$1 = d$$1;
  let i = Math.atan2(h$$1.y - g.y, h$$1.x - g.x);
  const j = util.getDistance(g, h$$1) - this.arrowsRadius;
  const k = g.x + (j + e) * Math.cos(i);
  const l = g.y + (j + e) * Math.sin(i);
  const m = h$$1.x + e * Math.cos(i);
  const n = h$$1.y + e * Math.sin(i);
  i -= Math.PI / 2;
  const o = {
    x: k + f * Math.cos(i),
    y: l + f * Math.sin(i)
  };
  const p = {
    x: k + f * Math.cos(i - Math.PI),
    y: l + f * Math.sin(i - Math.PI)
  };
  b.beginPath();
  b.fillStyle = 'rgba(' + this.strokeColor + ',' + this.alpha + ')';
  b.moveTo(o.x, o.y);
  b.lineTo(m, n);
  b.lineTo(p.x, p.y);
  b.stroke();
  b.closePath();

  if (flag) {
    return
  }

  this.bothArrow && this.paintArrow(b, d$$1, c, true);
};
Link.prototype.paint = function (a) {
  if (this.nodeA != null && !this.nodeZ != null) {
    const b = this.getPath(this.nodeIndex);
    this.path = b;
    a.strokeStyle = 'rgba(' + this.strokeColor + ',' + this.alpha + ')';
    a.lineWidth = this.lineWidth;
    this.paintPath(a, b);
    b && b.length > 0 && this.paintText(a, b);
  }
};
Link.prototype.paintText = function (a, b) {
  let c = b[0];
  let d$$1 = b[b.length - 1];
  b.length === 4 && (c = b[1], d$$1 = b[2]);
  if (this.text && this.text.length > 0) {
    let e = (d$$1.x + c.x) / 2 + this.textOffsetX;
    let f = (d$$1.y + c.y) / 2 + this.textOffsetY;
    a.save();
    a.beginPath();
    a.font = this.font;
    const g = a.measureText(this.text).width;
    const h$$1 = a.measureText('田').width;
    a.fillStyle = 'rgba(' + this.fontColor + ', ' + this.alpha + ')';
    if (this.nodeA === this.nodeZ) {
      const j = this.bundleGap * (this.nodeIndex + 1) / 2;
      e = this.nodeA.x + j * Math.cos(minus270);
      f = this.nodeA.y + j * Math.sin(minus270);
      a.fillText(this.text, e, f);
    } else {
      a.fillText(this.text, e - g / 2, f - h$$1 / 2);
    }
    a.stroke();
    a.closePath();
    a.restore();
  }
};
Link.prototype.paintSelected = function (a) {
  a.shadowBlur = 10;
  a.shadowColor = 'rgba(0,0,0,1)';
  a.shadowOffsetX = 0;
  a.shadowOffsetY = 0;
};
Link.prototype.isInBound = function (b, c) {
  if (this.nodeA === this.nodeZ) {
    const d$$1 = this.bundleGap * (this.nodeIndex + 1) / 2;
    const e = util.getDistance(this.nodeA, {
      x: b,
      y: c
    }) - d$$1;
    return Math.abs(e) <= 3
  }
  let f = false;
  for (let g = 1; g < this.path.length; g++) {
    const h$$1 = this.path[g - 1];
    const i = this.path[g];
    if (util.isPointInLine({
      x: b,
      y: c
    }, h$$1, i) === 1) {
      f = true;
      break
    }
  }
  return f
};

// import Node from './nodes/node'
// import Stage from './stage'
// import Scene from './scene'
const canvas = document.createElement('canvas');
const graphics = canvas.getContext('2d');
const alarmImageCache = {};

function getDistance(a, b, c, d) {
  let e,
    f;
  c == null && d == null ? (e = b.x - a.x, f = b.y - a.y) : (e = c - a, f = d - b);

  return Math.sqrt(e * e + f * f)
}

function getElementsBound(a) {
  const b = {
    left: Number.MAX_VALUE,
    right: Number.MIN_VALUE,
    top: Number.MAX_VALUE,
    bottom: Number.MIN_VALUE
  };
  for (let c = 0; c < a.length; c++) {
    const d = a[c];
    d instanceof Link || (b.left > d.x && (b.left = d.x, b.leftNode = d), b.right < d.x + d.width && (b.right = d.x + d.width, b.rightNode = d), b.top > d.y && (b.top = d.y, b.topNode = d), b.bottom < d.y + d.height && (b.bottom = d.y + d.height, b.bottomNode = d));
  }

  b.width = b.right - b.left;
  b.height = b.bottom - b.top;
  return b
}

function mouseCoords(a) {
  a = cloneEvent(a);
  a.pageX || (a.pageX = a.clientX + document.body.scrollLeft - document.body.clientLeft, a.pageY = a.clientY + document.body.scrollTop - document.body.clientTop);
  return a
}

function getEventPosition(a) {
  return mouseCoords(a)
}

function rotatePoint(a, b, c, d, e) {
  const f = c - a;
  const g = d - b;
  const h = Math.sqrt(f * f + g * g);
  const i = Math.atan2(g, f) + e;

  return {
    x: a + Math.cos(i) * h,
    y: b + Math.sin(i) * h
  }
}

function rotatePoints(a, b, c) {
  const d = [];
  for (let e = 0; e < b.length; e++) {
    const f = rotatePoint(a.x, a.y, b[e].x, b[e].y, c);
    d.push(f);
  }
  return d
}

function cloneEvent(a) {
  const b = {};
  for (const c in a) { c !== 'returnValue' && c !== 'keyLocation' && (b[c] = a[c]); }
  return b
}

function clone(a) {
  const b = {};
  for (const c in a) { b[c] = a[c]; }
  return b
}

function isPointInRect(a, b) {
  const c = b.x;
  const d = b.y;
  const e = b.width;
  const f = b.height;
  return a.x > c && a.x < c + e && a.y > d && a.y < d + f
}

function isPointInLine(a, b, c) {
  const d = getDistance(b, c);
  const e = getDistance(b, a);
  const f = getDistance(c, a);

  return Math.abs(e + f - d) <= 0.5
}

function removeFromArray(a, b) {
  for (let c = 0; c < a.length; c++) {
    const d = a[c];
    if (d === b) {
      a = a.del(c);
      break
    }
  }
  return a
}

function randomColor() {
  return Math.floor(255 * Math.random()) + ',' + Math.floor(255 * Math.random()) + ',' + Math.floor(255 * Math.random())
}
function isIntsect() { }
function getProperties(a, b) {
  let c = '';
  for (let d = 0; d < b.length; d++) {
    d > 0 && (c += ',');
    let e = a[b[d]];
    typeof e === 'string' ? e = '"' + e + '"' : void 0 === e && (e = null);
    c += b[d] + ':' + e;
  }
  return c
}

// function loadStageFromJson (json, canvas) {
//   const obj = eval(json)
//   const stage = new Stage(canvas)

//   for (let k in stageObj) {
//     if (k != 'scenes') { stage[k] = obj[k] } else {
//       for (let scenes = obj.scenes, i = 0; i < scenes.length; i++) {
//         let sceneObj = scenes[i],
//           scene = new Scene(stage)
//         for (let p in sceneObj) {
//           if (p != 'elements') { scene[p] = sceneObj[p] } else {
//             for (let nodeMap = {}, elements = sceneObj.elements, m = 0; m < elements.length; m++) {
//               let elementObj = elements[m],
//                 type = elementObj.elementType,
//                 element
//               type == 'Node' && (element = new Node())
//               for (let mk in elementObj) { element[mk] = elementObj[mk] }
//               nodeMap[element.text] = element,
//               scene.add(element)
//             }
//           }
//         }
//       }
//     }
//   }
//   console.log(stage)
//   return stage
// }

function toJson(a) {
  const b = 'backgroundColor,visible,mode,rotate,alpha,scaleX,scaleY,shadow,translateX,translateY,areaSelect,paintAll'.split(',');
  const c = 'text,elementType,x,y,width,height,visible,alpha,rotate,scaleX,scaleY,fillColor,shadow,transformAble,zIndex,dragable,selected,showSelected,font,fontColor,textPosition,textOffsetX,textOffsetY'.split(',');
  let d = '{';
  d += 'frames:' + a.frames;
  d += ', scenes:[';
  for (let e = 0; e < a.childs.length; e++) {
    const f = a.childs[e];
    d += '{';
    d += getProperties(f, b);
    d += ', elements:[';
    for (let g = 0; g < f.childs.length; g++) {
      const h = f.childs[g];
      g > 0 && (d += ',');
      d += '{';
      d += getProperties(h, c);
      d += '}';
    }
    d += ']}';
  }

  d += ']';
  d += '}';

  return d
}

function changeColor(a, b, c) {
  const d = c.split(',');
  const e = parseInt(d[0]);
  const f = parseInt(d[1]);
  const g = parseInt(d[2]);
  const h = canvas.width = b.width;
  const i = canvas.height = b.height;
  a.clearRect(0, 0, canvas.width, canvas.height);
  a.drawImage(b, 0, 0);
  const j = a.getImageData(0, 0, b.width, b.height);
  for (let k = j.data, l = 0; h > l; l++) {
    for (let m = 0; i > m; m++) {
      const n = 4 * (l + m * h);
      k[n + 3] !== 0 && (e != null && (k[n + 0] += e), f != null && (k[n + 1] += f), g != null && (k[n + 2] += g));
    }
  }
  a.putImageData(j, 0, 0, 0, 0, b.width, b.height);
  const o = canvas.toDataURL();
  return o
}

const Image = window.Image;

function genImageAlarm(a, b) {
  const c = a.src + b;
  if (alarmImageCache[c]) { return alarmImageCache[c] }
  const d = new Image();
  d.src = changeColor(graphics, a, b);
  alarmImageCache[c] = d;
  return d
}

function getOffsetPosition(a) {
  if (!a) {
    return {
      left: 0,
      top: 0
    }
  }
  let b = 0;
  let c = 0;
  if ('getBoundingClientRect' in document.documentElement) {
    const d = a.getBoundingClientRect();
    const e = a.ownerDocument;
    const f = e.body;
    const g = e.documentElement;
    const h = g.clientTop || f.clientTop || 0;
    const i = g.clientLeft || f.clientLeft || 0;
    b = d.top + (window.pageYOffset || g && g.scrollTop || f.scrollTop) - h;
    c = d.left + (window.pageXOffset || g && g.scrollLeft || f.scrollLeft) - i;
  } else {
    do {
      b += a.offsetTop || 0;
      c += a.offsetLeft || 0;
      a = a.offsetParent;
    } while (a)
  }

  return {
    left: c,
    top: b
  }
}

function lineF(a, b, c, d) {
  function e(a) {
    return a * f + g
  }
  const f = (d - b) / (c - a);
  const g = b - a * f;
  e.k = f;
  e.b = g;
  e.x1 = a;
  e.x2 = c;
  e.y1 = b;
  e.y2 = d;
  return e
}

function inRange(a, b, c) {
  const d = Math.abs(b - c);
  const e = Math.abs(b - a);
  const f = Math.abs(c - a);
  const g = Math.abs(d - (e + f));
  return g < 1e-6
}

function isPointInLineSeg(a, b, c) {
  return inRange(a, c.x1, c.x2) && inRange(b, c.y1, c.y2)
}

function intersection(a, b) {
  let c, d;

  if (a.k === b.k) {
    return null
  }
  1 / 0 === a.k || a.k === -1 / 0
    ? (c = a.x1, d = b(a.x1))
    : 1 / 0 === b.k || b.k === -1 / 0
      ? (c = b.x1, d = a(b.x1))
      : (c = (b.b - a.b) / (a.k - b.k), d = a(c));

  return isPointInLineSeg(c, d, a) === 0 ? null : isPointInLineSeg(c, d, b) === 0 ? null : {
    x: c,
    y: d
  }
}

function intersectionLineBound(a, b) {
  let c = lineF(b.left, b.top, b.left, b.bottom);
  let d = intersection(a, c);
  d == null && (c = lineF(b.left, b.top, b.right, b.top), d = intersection(a, c), d == null && (c = lineF(b.right, b.top, b.right, b.bottom), d = intersection(a, c), d == null && (c = lineF(b.left, b.bottom, b.right, b.bottom), d = intersection(a, c))));
  return d
}

function extend(SubClass, SuperClass) {
  // let F = function () { }
  // F.prototype = superClass.prototype
  SubClass.prototype = new SuperClass();
  SubClass.prototype.constructor = SubClass;

  // 防止超类改变原型
  SubClass.super = SuperClass.prototype;
}



const util = {
  rotatePoint: rotatePoint,
  rotatePoints: rotatePoints,
  getDistance: getDistance,
  getEventPosition: getEventPosition,
  mouseCoords: mouseCoords,
  isFirefox: navigator.userAgent.indexOf('Firefox') > 0,
  isIE: !(!window.attachEvent || navigator.userAgent.indexOf('Opera') !== -1),
  isChrome: navigator.userAgent.toLowerCase().match(/chrome/) != null,
  clone: clone,
  isPointInRect: isPointInRect,
  isPointInLine: isPointInLine,
  removeFromArray: removeFromArray,
  cloneEvent: cloneEvent,
  randomColor: randomColor,
  isIntsect: isIntsect,
  toJson: toJson,
  // loadStageFromJson: loadStageFromJson,
  getElementsBound: getElementsBound,
  genImageAlarm: genImageAlarm,
  getOffsetPosition: getOffsetPosition,
  lineF: lineF,
  intersection: intersection,
  intersectionLineBound: intersectionLineBound,
  extend: extend
};

function createEagleEye(a) {
  return {
    hgap: 16,
    visible: false,
    exportCanvas: document.createElement('canvas'),
    getImage: function (b, c) {
      const d = a.getBound();
      let e = 1;
      let f = 1;
      this.exportCanvas.width = a.canvas.width;
      this.exportCanvas.height = a.canvas.height;
      b != null && c != null ? (this.exportCanvas.width = b, this.exportCanvas.height = c, e = b / d.width, f = c / d.height) : (d.width > a.canvas.width && (this.exportCanvas.width = d.width), d.height > a.canvas.height && (this.exportCanvas.height = d.height));
      const g = this.exportCanvas.getContext('2d');
      a.childs.length > 0 && (g.save(), g.clearRect(0, 0, this.exportCanvas.width, this.exportCanvas.height), a.childs.forEach(function (a) {
        a.visible && (a.save(), a.translateX = 0, a.translateY = 0, a.scaleX = 1, a.scaleY = 1, g.scale(e, f), d.left < 0 && (a.translateX = Math.abs(d.left)), d.top < 0 && (a.translateY = Math.abs(d.top)), a.paintAll = true, a.repaint(g), a.paintAll = false, a.restore());
      }), g.restore());
      return this.exportCanvas.toDataURL('image/png')
    },
    canvas: document.createElement('canvas'),
    update: function () {
      this.eagleImageDatas = this.getData(a);
    },
    setSize: function (a, b) {
      this.width = this.canvas.width = a;
      this.height = this.canvas.height = b;
    },
    getData: function (b, c) {
      function d(a) {
        const b = a.stage.canvas.width;
        const c = a.stage.canvas.height;
        const d = b / a.scaleX / 2;
        const e = c / a.scaleY / 2;
        return {
          translateX: a.translateX + d - d * a.scaleX,
          translateY: a.translateY + e - e * a.scaleY
        }
      }
      // TODO: 这行执行不到
      // j != null && k != null ? this.setSize(b, c) : this.setSize(200, 160)
      const e = this.canvas.getContext('2d');
      if (a.childs.length > 0) {
        e.save();
        e.clearRect(0, 0, this.canvas.width, this.canvas.height);
        a.childs.forEach(function (a) {
          a.visible && (a.save(), a.centerAndZoom(null, null, e), a.repaint(e), a.restore());
        });
        const f = d(a.childs[0]);
        let g = f.translateX * (this.canvas.width / a.canvas.width) * a.childs[0].scaleX;
        let h = f.translateY * (this.canvas.height / a.canvas.height) * a.childs[0].scaleY;
        const i = a.getBound();
        let j = a.canvas.width / a.childs[0].scaleX / i.width;
        const k = a.canvas.height / a.childs[0].scaleY / i.height;
        j > 1 && (j = 1);
        k > 1 && (j = 1);
        g *= j;
        h *= k;
        i.left < 0 && (g -= Math.abs(i.left) * (this.width / i.width));
        i.top < 0 && (h -= Math.abs(i.top) * (this.height / i.height));
        e.save();
        e.lineWidth = 1;
        e.strokeStyle = 'rgba(255,0,0,1)';
        e.strokeRect(-g, -h, e.canvas.width * j, e.canvas.height * k);
        e.restore();
        let l = null;
        try {
          l = e.getImageData(0, 0, e.canvas.width, e.canvas.height);
        } catch (m) { }
        return l
      }
      return null
    },
    paint: function () {
      if (this.eagleImageDatas != null) {
        const b = a.graphics;
        b.save();
        b.fillStyle = 'rgba(211,211,211,0.3)';
        b.fillRect(a.canvas.width - this.canvas.width - 2 * this.hgap, a.canvas.height - this.canvas.height - 1, a.canvas.width - this.canvas.width, this.canvas.height + 1);
        b.fill();
        b.save();
        b.lineWidth = 1;
        b.strokeStyle = 'rgba(0,0,0,1)';
        b.rect(a.canvas.width - this.canvas.width - 2 * this.hgap, a.canvas.height - this.canvas.height - 1, a.canvas.width - this.canvas.width, this.canvas.height + 1);
        b.stroke();
        b.restore();
        b.putImageData(this.eagleImageDatas, a.canvas.width - this.canvas.width - this.hgap, a.canvas.height - this.canvas.height);
        b.restore();
      } else { this.eagleImageDatas = this.getData(a); }
    },
    eventHandler: function (a, b, c) {
      let d = b.x;
      let e = b.y;
      if (d > c.canvas.width - this.canvas.width && e > c.canvas.height - this.canvas.height) {
        d = b.x - this.canvas.width;
        e = b.y - this.canvas.height;
        a === 'mousedown' && (this.lastTranslateX = c.childs[0].translateX, this.lastTranslateY = c.childs[0].translateY);
        if (a === 'mousedrag' && c.childs.length > 0) {
          const f = b.dx;
          const g = b.dy;
          const h = c.getBound();
          const i = this.canvas.width / c.childs[0].scaleX / h.width;
          const j = this.canvas.height / c.childs[0].scaleY / h.height;
          c.childs[0].translateX = this.lastTranslateX - f / i;
          c.childs[0].translateY = this.lastTranslateY - g / j;
        }
      }
    }
  }
}

function Stage(c) {
  // TODO:
  // JTopo.stage = this
  const n = this;

  c != null && this.initialize(c);

  const q = 'click,dbclick,mousedown,mouseup,mouseover,mouseout,mousemove,mousedrag,mousewheel,touchstart,touchmove,touchend,keydown,keyup'.split(',');

  q.forEach((a) => {
    this[a] = function (b) {
      b != null ? this.addEventListener(a, b) : this.dispatchEvent(a);
    };
  });

  (function frameLoop() {
    debugger
    n.frames === 0
      ? setTimeout(frameLoop, 100)
      : n.frames < 0
        ? (n.repaint(), setTimeout(frameLoop, 1e3 / -n.frames))
        : (n.repaint(), setTimeout(frameLoop, 1e3 / n.frames));
  }());

  setTimeout(function () {
    n.mousewheel(function (a) {
      const b = a.wheelDelta == null ? a.detail : a.wheelDelta;
      this.wheelZoom != null && (b > 0 ? this.zoomIn(this.wheelZoom) : this.zoomOut(this.wheelZoom));
    });
    n.paint();
  }, 300);

  setTimeout(function () {
    n.paint();
  }, 1e3);

  setTimeout(function () {
    n.paint();
  }, 3e3);
}

Stage.prototype.initialize = function (c) {
  this.bindEvent(c);
  this.canvas = c;
  this.graphics = c.getContext('2d');
  this.childs = [];
  this.frames = 24;
  this.messageBus = new util.MessageBus();
  this.eagleEye = createEagleEye(this);
  this.wheelZoom = null;
  this.mouseDownX = 0;
  this.mouseDownY = 0;
  this.mouseDown = false;
  this.mouseOver = false;
  this.needRepaint = true;
  this.serializedProperties = ['frames', 'wheelZoom'];
};

// TODO:
Stage.prototype.bindEvent = function (c) {
  const n = this;
  let o = true;
  let p = null;

  function d(b) {
    const c = util.getEventPosition(b);
    const d = util.getOffsetPosition(n.canvas);

    c.offsetLeft = c.pageX - d.left;
    c.offsetTop = c.pageY - d.top;
    c.x = c.offsetLeft;
    c.y = c.offsetTop;
    c.target = null;
    return c
  }

  function e(a) {
    document.onselectstart = function () {
      return false
    };
    this.mouseOver = true;
    const b = d(a);
    n.dispatchEventToScenes('mouseover', b);
    n.dispatchEvent('mouseover', b);
  }

  function f(a) {
    p = setTimeout(function () {
      o = true;
    }, 500);
    document.onselectstart = function () {
      return true
    };
    const b = d(a);
    n.dispatchEventToScenes('mouseout', b);
    n.dispatchEvent('mouseout', b);
    n.needRepaint = n.animate !== 0;
  }

  function g(a) {
    const b = d(a);
    n.mouseDown = true;
    n.mouseDownX = b.x;
    n.mouseDownY = b.y;
    n.dispatchEventToScenes('mousedown', b);
    n.dispatchEvent('mousedown', b);
  }

  function h(a) {
    const b = d(a);
    n.dispatchEventToScenes('mouseup', b);
    n.dispatchEvent('mouseup', b);
    n.mouseDown = false;
    n.needRepaint = n.animate !== 0;
  }

  function i(a) {
    p && (window.clearTimeout(p), p = null);
    o = false;
    const b = d(a);
    n.mouseDown ? a.button === 0 && (b.dx = b.x - n.mouseDownX, b.dy = b.y - n.mouseDownY, n.dispatchEventToScenes('mousedrag', b), n.dispatchEvent('mousedrag', b), n.eagleEye.visible && n.eagleEye.update()) : (n.dispatchEventToScenes('mousemove', b), n.dispatchEvent('mousemove', b));
  }

  function j(a) {
    const b = d(a);
    n.dispatchEventToScenes('click', b);
    n.dispatchEvent('click', b);
  }

  function k(a) {
    const b = d(a);
    n.dispatchEventToScenes('dbclick', b);
    n.dispatchEvent('dbclick', b);
  }

  function l(a) {
    const b = d(a);
    n.dispatchEventToScenes('mousewheel', b);
    n.dispatchEvent('mousewheel', b);
    n.wheelZoom != null && (a.preventDefault ? a.preventDefault() : (a = a || window.event, a.returnValue = false), n.eagleEye.visible && n.eagleEye.update());
  }

  function m(b) {
    util.isIE || !window.addEventListener ? (b.onmouseout = f, b.onmouseover = e, b.onmousedown = g, b.onmouseup = h, b.onmousemove = i, b.onclick = j, b.ondblclick = k, b.onmousewheel = l, b.touchstart = g, b.touchmove = i, b.touchend = h) : (b.addEventListener('mouseout', f), b.addEventListener('mouseover', e), b.addEventListener('mousedown', g), b.addEventListener('mouseup', h), b.addEventListener('mousemove', i), b.addEventListener('click', j), b.addEventListener('dblclick', k), util.isFirefox ? b.addEventListener('DOMMouseScroll', l) : b.addEventListener('mousewheel', l));
    window.addEventListener && (window.addEventListener('keydown', function (b) {
      n.dispatchEventToScenes('keydown', util.cloneEvent(b));
      const c = b.keyCode;
      (c === 37 || c === 38 || c === 39 || c === 40) && (b.preventDefault ? b.preventDefault() : (b = b || window.event, b.returnValue = false));
    }, true), window.addEventListener('keyup', function (b) {
      n.dispatchEventToScenes('keyup', util.cloneEvent(b));
      const c = b.keyCode;
      (c === 37 || c === 38 || c === 39 || c === 40) && (b.preventDefault ? b.preventDefault() : (b = b || window.event, b.returnValue = false));
    }, true));
  }

  document.oncontextmenu = function () {
    return o
  };

  m(c);
};

Stage.prototype.dispatchEventToScenes = function (a, b) {
  this.frames !== 0 && (this.needRepaint = true);
  if (this.eagleEye.visible && a.indexOf('mouse') !== -1) {
    const c = b.x;
    const d = b.y;
    if (c > this.width - this.eagleEye.width && d > this.height - this.eagleEye.height) { return void this.eagleEye.eventHandler(a, b, this) }
  }
  this.childs.forEach(function (c) {
    if (c.visible) {
      const d = c[a + 'Handler'];
      if (d == null) { throw new Error('Function not found:' + a + 'Handler') }
      d.call(c, b);
    }
  });
};

Stage.prototype.add = function (a) {
  for (let b = 0; b < this.childs.length; b++) {
    if (this.childs[b] === a) { return }
  }
  a.addTo(this);
  this.childs.push(a);
};

Stage.prototype.remove = function (a) {
  if (a == null) { throw new Error('Stage.remove出错: 参数为null!') }
  for (let b = 0; b < this.childs.length; b++) {
    if (this.childs[b] === a) {
      a.stage = null;
      this.childs = this.childs.del(b);
      return this
    }
  }
  return this
};

Stage.prototype.clear = function () {
  this.childs = [];
};

Stage.prototype.addEventListener = function (a, b) {
  const c = this;
  const d = function (a) {
    b.call(c, a);
  };

  this.messageBus.subscribe(a, d);

  return this
};

Stage.prototype.removeEventListener = function (a) {
  this.messageBus.unsubscribe(a);
};

Stage.prototype.removeAllEventListener = function () {
  this.messageBus = new util.MessageBus();
};

Stage.prototype.dispatchEvent = function (a, b) {
  this.messageBus.publish(a, b);
  return this
};

Stage.prototype.saveImageInfo = function (a, b) {
  const c = this.eagleEye.getImage(a, b);
  const d = window.open('about:blank');
  d.document.write("<img src='" + c + "' alt='from canvas'/>");
  return this
};

Stage.prototype.saveAsLocalImage = function (a, b) {
  const c = this.eagleEye.getImage(a, b);
  c.replace('image/png', 'image/octet-stream');
  window.location.href = c;
  return this
};

Stage.prototype.paint = function () {
  if (!this.canvas) {
    return
  }
  const graphics = this.graphics;
  graphics.save();
  graphics.clearRect(0, 0, this.width, this.height);
  this.childs.forEach(function (a) {
    a.visible && a.repaint(graphics);
  });
  this.eagleEye.visible && this.eagleEye.paint(this);
  graphics.restore();
};

Stage.prototype.repaint = function () {
  this.frames !== 0 && (this.frames < 0 && this.needRepaint || (this.paint(), this.frames < 0 && (this.needRepaint = false)));
};

Stage.prototype.zoom = function (a) {
  this.childs.forEach(function (b) {
    b.visible && b.zoom(a);
  });
};

Stage.prototype.zoomOut = function (a) {
  this.childs.forEach(function (b) {
    b.visible && b.zoomOut(a);
  });
};

Stage.prototype.zoomIn = function (a) {
  this.childs.forEach(function (b) {
    b.visible && b.zoomIn(a);
  });
};

Stage.prototype.centerAndZoom = function () {
  this.childs.forEach(function (a) {
    a.visible && a.centerAndZoom();
  });
};

Stage.prototype.setCenter = function (a, b) {
  const c = this;
  this.childs.forEach(function (d) {
    const e = a - c.canvas.width / 2;
    const f = b - c.canvas.height / 2;
    d.translateX = -e;
    d.translateY = -f;
  });
};

Stage.prototype.getBound = function () {
  const a = {
    left: Number.MAX_VALUE,
    right: Number.MIN_VALUE,
    top: Number.MAX_VALUE,
    bottom: Number.MIN_VALUE
  };
  this.childs.forEach(function (b) {
    const c = b.getElementsBound();
    c.left < a.left && (a.left = c.left, a.leftNode = c.leftNode);
    c.top < a.top && (a.top = c.top, a.topNode = c.topNode);
    c.right > a.right && (a.right = c.right, a.rightNode = c.rightNode);
    c.bottom > a.bottom && (a.bottom = c.bottom, a.bottomNode = c.bottomNode);
  });
  a.width = a.right - a.left;
  a.height = a.bottom - a.top;
  return a
};

Stage.prototype.toJson = function () {
  const b = this;
  let c = '{"version":"' + version + '",';
  // this.serializedProperties.length

  this.serializedProperties.forEach(function (a) {
    let d = b[a];
    typeof d === 'string' && (d = '"' + d + '"');
    c += '"' + a + '":' + d + ',';
  });

  c += '"childs":[';

  this.childs.forEach(function (a) {
    c += a.toJson();
  });

  c += ']';
  c += '}';

  return c
};

Stage.prototype.find = find;

Object.defineProperties(Stage.prototype, {
  width: {
    get() {
      return this.canvas.width
    }
  },

  height: {
    get() {
      return this.canvas.height
    }
  },

  cursor: {
    set(a) {
      this.canvas.style.cursor = a;
    },
    get() {
      return this.canvas.style.cursor
    }
  },

  mode: {
    set(a) {
      this.childs.forEach(function (b) {
        b.mode = a;
      });
    },
    get() {
      return this.childs.map(function (b) {
        return b.mode
      })
    }
  }
});

function TextNode(text) {
  this.initialize();
  this.text = text;
  this.elementType = 'TextNode';
}

util.extend(TextNode, Node);

TextNode.prototype.paint = function (a) {
  a.beginPath();
  a.font = this.font;
  this.width = a.measureText(this.text).width;
  this.height = a.measureText('田').width;
  a.strokeStyle = 'rgba(' + this.fontColor + ', ' + this.alpha + ')';
  a.fillStyle = 'rgba(' + this.fontColor + ', ' + this.alpha + ')';
  a.fillText(this.text, -this.width / 2, this.height / 2);
  a.closePath();
  this.paintBorder(a);
  this.paintCtrl(a);
  this.paintAlarmText(a);
};

function LinkNode(a, b, c) {
  this.initialize();

  this.text = a;
  this.href = b;
  this.target = c;
  this.elementType = 'LinkNode';
  this.isVisited = false;
  this.visitedColor = null;
  this.mousemove(function () {
    const a = document.getElementsByTagName('canvas');
    if (a && a.length > 0) {
      for (let b = 0; b < a.length; b++) { a[b].style.cursor = 'pointer'; }
    }
  });
  this.mouseout(function () {
    const a = document.getElementsByTagName('canvas');
    if (a && a.length > 0) {
      for (let b = 0; b < a.length; b++) { a[b].style.cursor = 'default'; }
    }
  });
  this.click(function () {
    this.target === '_blank' ? window.open(this.href) : window.location = this.href;
    this.isVisited = true;
  });
}

util.extend(LinkNode, TextNode);

LinkNode.prototype.paint = function (a) {
  a.beginPath();
  a.font = this.font;
  this.width = a.measureText(this.text).width;
  this.height = a.measureText('田').width;
  this.isVisited && this.visitedColor != null ? (a.strokeStyle = 'rgba(' + this.visitedColor + ', ' + this.alpha + ')', a.fillStyle = 'rgba(' + this.visitedColor + ', ' + this.alpha + ')') : (a.strokeStyle = 'rgba(' + this.fontColor + ', ' + this.alpha + ')', a.fillStyle = 'rgba(' + this.fontColor + ', ' + this.alpha + ')');
  a.fillText(this.text, -this.width / 2, this.height / 2);
  this.isMouseOver && (a.moveTo(-this.width / 2, this.height), a.lineTo(this.width / 2, this.height), a.stroke());
  a.closePath();
  this.paintBorder(a);
  this.paintCtrl(a);
  this.paintAlarmText(a);
};

function CircleNode(a) {
  this.initialize(arguments);
  this._radius = 20;
  this.beginDegree = 0;
  this.endDegree = 2 * Math.PI;
  this.text = a;
}

util.extend(CircleNode, Node);

Object.defineProperties(CircleNode.prototype, {
  radius: {
    get: function () {
      return this._radius
    },
    set: function (a) {
      this._radius = a;
      const b = 2 * this.radius;
      const c = 2 * this.radius;
      this.width = b;
      this.height = c;
    }
  },
  width: {
    get: function () {
      return this._width
    },
    set: function (a) {
      this._radius = a / 2;
      this._width = a;
    }
  },
  height: {
    get: function () {
      return this._height
    },
    set: function (a) {
      this._radius = a / 2;
      this._height = a;
    }
  }
});

CircleNode.prototype.paint = function (a) {
  a.save();
  a.beginPath();
  a.fillStyle = 'rgba(' + this.fillColor + ',' + this.alpha + ')';
  a.arc(0, 0, this.radius, this.beginDegree, this.endDegree, true);
  a.fill();
  a.closePath();
  a.restore();
  this.paintText(a);
  this.paintBorder(a);
  this.paintCtrl(a);
  this.paintAlarmText(a);
};

CircleNode.prototype.paintSelected = function (a) {
  a.save();
  a.beginPath();
  a.strokeStyle = 'rgba(168,202,255, 0.9)';
  a.fillStyle = 'rgba(168,202,236,0.7)';
  a.arc(0, 0, this.radius + 3, this.beginDegree, this.endDegree, true);
  a.fill();
  a.stroke();
  a.closePath();
  a.restore();
};

function G(a, b, c) {
  this.initialize();
  this.frameImages = a || [];
  this.frameIndex = 0;
  this.isStop = true;
  const d = b || 1e3;
  this.repeatPlay = false;
  const e = this;
  this.nextFrame = function () {
    if (!this.isStop && this.frameImages.length != null) {
      this.frameIndex++;
      if (this.frameIndex >= this.frameImages.length) {
        if (!this.repeatPlay) { return }
        this.frameIndex = 0;
      }
      this.setImage(this.frameImages[this.frameIndex], c);
      setTimeout(function () {
        e.nextFrame();
      }, d / a.length);
    }
  };
}

function H(a, b, c, d, e) {
  this.initialize();
  this.setImage(a);
  this.frameIndex = 0;
  this.isPause = true;
  this.repeatPlay = false;
  const g = d || 1e3;
  e = e || 0;

  this.paint = function (a) {
    if (this.image) {
      const b = this.width;
      const d = this.height;
      a.save();
      a.beginPath();
      a.fillStyle = 'rgba(' + this.fillColor + ',' + this.alpha + ')';
      const f = (Math.floor(this.frameIndex / c) + e) * d;
      const g = Math.floor(this.frameIndex % c) * b;
      a.drawImage(this.image, g, f, b, d, -b / 2, -d / 2, b, d);
      a.fill();
      a.closePath();
      a.restore();
      this.paintText(a);
      this.paintBorder(a);
      this.paintCtrl(a);
      this.paintAlarmText(a);
    }
  };

  this.nextFrame = function () {
    if (!this.isStop) {
      this.frameIndex++;
      if (this.frameIndex >= b * c) {
        if (!this.repeatPlay) { return }
        this.frameIndex = 0;
      }
      setTimeout(() => {
        this.isStop || this.nextFrame();
      }, g / (b * c));
    }
  };
}

util.extend(G, Node);
util.extend(H, Node);

function AnimateNode() {
  let a = null;
  a = arguments.length <= 3
    ? new G(arguments[0], arguments[1], arguments[2])
    : new H(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
  a.stop = function () {
    a.isStop = true;
  };
  a.play = function () {
    a.isStop = false;
    a.frameIndex = 0;
    a.nextFrame();
  };
  return a
}

util.extend(AnimateNode, Node);

function FoldLink(a, b, c) {
  this.initialize(a, b, c);
}

util.extend(FoldLink, Link);

FoldLink.prototype.initialize = function () {
  FoldLink.super.initialize.apply(this, arguments);
  this.direction = 'horizontal';
};
FoldLink.prototype.getStartPosition = function () {
  const a = {
    x: this.nodeA.cx,
    y: this.nodeA.cy
  };
  this.direction === 'horizontal' ? this.nodeZ.cx > a.x ? a.x += this.nodeA.width / 2 : a.x -= this.nodeA.width / 2 : this.nodeZ.cy > a.y ? a.y += this.nodeA.height / 2 : a.y -= this.nodeA.height / 2;
  return a
};
FoldLink.prototype.getEndPosition = function () {
  const a = {
    x: this.nodeZ.cx,
    y: this.nodeZ.cy
  };
  this.direction === 'horizontal' ? this.nodeA.cy < a.y ? a.y -= this.nodeZ.height / 2 : a.y += this.nodeZ.height / 2 : a.x = this.nodeA.cx < a.x ? this.nodeZ.x : this.nodeZ.x + this.nodeZ.width;
  return a
};
FoldLink.prototype.getPath = function (a) {
  const b = [];
  const c = this.getStartPosition();
  const d$$1 = this.getEndPosition();
  if (this.nodeA === this.nodeZ) { return [c, d$$1] }
  let f;
  let g;
  const h$$1 = e$1(this.nodeA, this.nodeZ);
  const i = (h$$1 - 1) * this.bundleGap;
  const j = this.bundleGap * a - i / 2;
  this.direction === 'horizontal' ? (f = d$$1.x + j, g = c.y - j, b.push({
    x: c.x,
    y: g
  }), b.push({
    x: f,
    y: g
  }), b.push({
    x: f,
    y: d$$1.y
  })) : (f = c.x + j, g = d$$1.y - j, b.push({
    x: f,
    y: c.y
  }), b.push({
    x: f,
    y: g
  }), b.push({
    x: d$$1.x,
    y: g
  }));
  return b
};
FoldLink.prototype.paintText = function (a, b) {
  if (this.text && this.text.length > 0) {
    const c = b[1];
    const d$$1 = c.x + this.textOffsetX;
    const e = c.y + this.textOffsetY;
    a.save();
    a.beginPath();
    a.font = this.fon;
    const f = a.measureText(this.text).width;
    const g = a.measureText('田').width;
    a.fillStyle = 'rgba(' + this.fontColor + ', ' + this.alpha + ')';
    a.fillText(this.text, d$$1 - f / 2, e - g / 2);
    a.stroke();
    a.closePath();
    a.restore();
  }
};

function FlexionalLink(a, b, c) {
  this.initialize(a, b, c);
}

util.extend(FlexionalLink, Link);

FlexionalLink.prototype.initialize = function () {
  FlexionalLink.super.initialize.apply(this, arguments);
  this.direction = 'vertical';
  this.offsetGap = 44;
};
FlexionalLink.prototype.getStartPosition = function () {
  const a = {
    x: this.nodeA.cx,
    y: this.nodeA.cy
  };
  this.direction === 'horizontal' ? a.x = this.nodeZ.cx < a.x ? this.nodeA.x : this.nodeA.x + this.nodeA.width : a.y = this.nodeZ.cy < a.y ? this.nodeA.y : this.nodeA.y + this.nodeA.height;
  return a
};
FlexionalLink.prototype.getEndPosition = function () {
  const a = {
    x: this.nodeZ.cx,
    y: this.nodeZ.cy
  };
  this.direction === 'horizontal' ? a.x = this.nodeA.cx < a.x ? this.nodeZ.x : this.nodeZ.x + this.nodeZ.width : a.y = this.nodeA.cy < a.y ? this.nodeZ.y : this.nodeZ.y + this.nodeZ.height;

  return a
};
FlexionalLink.prototype.getPath = function (a) {
  const b = this.getStartPosition();
  const c = this.getEndPosition();
  if (this.nodeA === this.nodeZ) {
    return [b, c]
  }
  const d$$1 = [];
  const f = e$1(this.nodeA, this.nodeZ);
  const g = (f - 1) * this.bundleGap;
  const h$$1 = this.bundleGap * a - g / 2;
  let i = this.offsetGap;
  this.direction === 'horizontal' ? (this.nodeA.cx > this.nodeZ.cx && (i = -i), d$$1.push({
    x: b.x,
    y: b.y + h$$1
  }), d$$1.push({
    x: b.x + i,
    y: b.y + h$$1
  }), d$$1.push({
    x: c.x - i,
    y: c.y + h$$1
  }), d$$1.push({
    x: c.x,
    y: c.y + h$$1
  })) : (this.nodeA.cy > this.nodeZ.cy && (i = -i), d$$1.push({
    x: b.x + h$$1,
    y: b.y
  }), d$$1.push({
    x: b.x + h$$1,
    y: b.y + i
  }), d$$1.push({
    x: c.x + h$$1,
    y: c.y - i
  }), d$$1.push({
    x: c.x + h$$1,
    y: c.y
  }));

  return d$$1
};

function CurveLink(a, b, c) {
  this.initialize(a, b, c);
}

util.extend(CurveLink, Link);

CurveLink.prototype.initialize = function () {
  CurveLink.super.initialize.apply(this, arguments);
};
CurveLink.prototype.paintPath = function (a, b) {
  if (this.nodeA === this.nodeZ) {
    return void this.paintLoop(a)
  }
  a.beginPath();
  a.moveTo(b[0].x, b[0].y);
  for (let c = 1; c < b.length; c++) {
    const d = b[c - 1];
    const e = b[c];
    const f = (d.x + e.x) / 2;
    let g = (d.y + e.y) / 2;
    g += (e.y - d.y) / 2;
    a.strokeStyle = 'rgba(' + this.strokeColor + ',' + this.alpha + ')';
    a.lineWidth = this.lineWidth;
    a.moveTo(d.x, d.cy);
    a.quadraticCurveTo(f, g, e.x, e.y);
    a.stroke();
  }
  a.stroke();
  a.closePath();
  if (this.arrowsRadius != null) {
    const h = b[b.length - 2];
    const i = b[b.length - 1];
    this.paintArrow(a, h, i);
  }
};

const JTopo = {
  Stage,
  Scene,
  // nodes
  Node,
  TextNode,
  LinkNode,
  CircleNode,
  AnimateNode,

  // links
  Link,
  FoldLink,
  FlexionalLink,
  CurveLink
};

extendNative();

return JTopo;

})));
